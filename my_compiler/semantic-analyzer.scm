(define remove-applic-lambda-nil
  	(lambda (expr)
    	(cond ((null? expr) expr)
       		((and (list? expr) 
       			  (equal? (car expr) 'applic)
       			  (equal? (car (cadr expr)) 'lambda-simple)
       			  (list? (cadr expr)) 
       			  (null? (cadadr expr)) 
       			  (null? (caddr expr))) 
       				  (remove-applic-lambda-nil (car (cddadr expr)))) 
          	((list? expr) (map remove-applic-lambda-nil expr))
          	(else expr)
        )
	)
)  

(define remove-seq
	(lambda (expr)
		(fold-right
			(lambda (x y)
				(if (equal? (car x) 'seq)
					(append (remove-seq (cdr x)) y)
					(if (list? (car x))
						(append x y)
						(cons x y))))
			(list) expr
		)
	)
)

(define or-map
  	(lambda (p x)
    	(if (null? x)
        	#f
        	(or (p (car x))
            	(or-map p (cdr x))
        	)
    	)
	)
)

(define box-set-aux-body
 	(lambda (params body)
    	(cond ((null? body) body)
          	((and (list? body) (equal? 'lambda-simple (car body)) (member params (cadr body))) body)
          	((and (list? body) (equal? 'lambda-opt (car body)) (member params (append (cadr body) `(,(caddr body))))) body)
          	((and (list? body) (equal? `(var ,params) body)) `(box-get (var ,params)))
          	((and (list? body) (equal? 'set (car body)) (equal? `(var ,params) (cadr body))) `(box-set (var ,params) ,@(box-set-aux-body params (cddr body))))
          	((list? body) `(,(box-set-aux-body params (car body)) ,@(box-set-aux-body params (cdr body))))
          	(else body)
      	)
	)
)


(define check-if-bound?
  	(lambda (params body)
    	(cond ((null? body) #f)
	          ((and (list? body) (equal? 'lambda-simple (car body)) (not (member params (cadr body)))) (check-if-bound-lambda? params (cddr body)))
	          ((and (list? body) (equal? 'lambda-simple (car body)) (member params (cadr body))) #f)
	          ((and (list? body) (equal? 'lambda-opt (car body)) (not (member params (append (cadr body) `(,(caddr body)))))) (check-if-bound-lambda? params (cdddr body)))
	          ((and (list? body) (equal? 'lambda-opt (car body)) (member params (append (cadr body) `(,(caddr body))))) #f)
	          ((list? body) (or-map (lambda (p) (check-if-bound? params p)) body))
	          (else #f)
      	)
    )
)

(define check-if-bound-lambda?
  	(lambda (params body)
    	(cond ((null? body) #f)
	          ((and (list? body) (equal? 'lambda-simple (car body)) (member params (cadr body))) #f)
	          ((and (list? body) (equal? 'lambda-opt (car body)) (member params (append (cadr body) `(,(caddr body))))) #f) 
	          ((equal? `(var ,params) body) #t)
	          ((list? body) (or-map (lambda (p) (check-if-bound-lambda? params p)) body))
	          (else #f)
        )
    )
)

(define check-set?
  	(lambda (params body)
    	(cond ((null? body) #f)
	    	  ((and (list? body) (equal? 'lambda-simple (car body)) (member params (cadr body))) #f)
	          ((and (list? body) (equal? 'lambda-opt (car body)) (member params (append (cadr body) `(,(caddr body))))) #f)
	          ((and (list? body) (equal? 'set (car body)) (equal? `(var ,params) (cadr body))) #t)
	          ((list? body) (or-map (lambda (p) (check-set? params p)) body))
	          (else #f)
        )
    )
)

(define check-get?
  	(lambda (params body)
    	(cond ((null? body) #f)
	    	  ((and (list? body) (equal? 'lambda-simple (car body)) (member params (cadr body))) #f)
	          ((and (list? body) (equal? 'lambda-opt (car body)) (member params (append (cadr body) `(,(caddr body))))) #f)
	          ((and (list? body) (equal? `(var ,params) body)) #t)
	          ((and (list? body) (equal? 'set (car body)) (equal? `(var ,params) (cadr body))) (check-get? params (cddr body)))
	          ((list? body) (or-map (lambda (p) (check-get? params p)) body))
	          (else #f)
        )
    )
)

(define box-set
  	(lambda (expr)
    	(cond ((null? expr) expr)
        	  ((and (list? expr) (equal? 'lambda-simple (car expr)))
           		(let* ((body (cddr expr))
                       (bvars (filter (lambda (p)  (and (check-if-bound? p body) (check-set? p body) (check-get? p body))) (cadr expr))))
             	(if (null? bvars)
                 	`(lambda-simple ,(cadr expr) ,@(box-set body))
                  	(let ((new-expr `(,@(map (lambda (p)  `(set (var ,p) (box (var ,p)))) bvars) ,@(box-set-aux body bvars))))
                 	`(lambda-simple ,(cadr expr) (seq ,(remove-seq new-expr)))))))
        	  ((and (list? expr) (equal? 'lambda-opt (car expr)))
        	   (let* ((body (cdddr expr))
            	      (bvars (filter (lambda (p)  (and (check-if-bound? p body) (check-set? p body) (check-get? p body))) (append (cadr expr) `(,(caddr expr))))))
            	 (if (null? bvars)
                	 `(lambda-opt ,(cadr expr) ,(caddr expr) ,@(box-set body))
                  	 (let ((new-expr `(,@(map (lambda (p)  `(set (var ,p) (box (var ,p)))) bvars) ,@(box-set-aux body bvars))))
                	 `(lambda-opt ,(cadr expr) ,(caddr expr) (seq ,(remove-seq new-expr)))))))
        	  ((list? expr) (map box-set expr))
        	  (else expr)
      	)
	)
)

(define box-set-aux
  	(lambda (body params)
    	(if (null? params)
        	(box-set body)
        	(let ((new-body (box-set-aux-body (car params) body)))
          	   (box-set-aux new-body (cdr params)))
   		)
    )
)


(define counter
	(lambda ()
		(let ((n -1))
			(lambda ()
				(set! n (+ n 1))
			n)
		)
	)
)


(define pe->lex-pe
	(lambda (pe)
		(cond ((null? pe) pe)
			((and (list? pe) (equal? (car pe) 'var)) `(fvar ,(cadr pe)))  
			((and (list? pe) (equal? 'lambda-simple (car pe)))
			(let* ((pvar-location (counter))
				  (pvars (make-pvars (lambda (x) `(pvar ,x ,(pvar-location))) (cadr pe)))
				  (lambda-body (cddr pe)))
			 `(lambda-simple ,(cadr pe) ,@(raplace-var-pvar lambda-body pvars))))
			((and (list? pe) (equal? 'lambda-opt (car pe)))
			(let* ((pvar-location (counter))
				  (pvars (make-pvars (lambda (x) `(pvar ,x ,(pvar-location))) (append (cadr pe) `(,(caddr pe)))))
				  (lambda-body (cdddr pe)))
			 `(lambda-opt ,(cadr pe) ,(caddr pe) ,@(raplace-var-pvar lambda-body pvars))))
			((list? pe) (map pe->lex-pe pe))
			(else pe)
		)
	)
)

(define raplace-var-pvar
	(lambda (body pvars)
		(if (null? pvars) (pe->lex-pe body)
			(letrec ((helper 
						(lambda (body pvar)
							(cond ((null? body) body)
								  ((and (list? body) (equal? `(var ,(cadr pvar)) body)) pvar)
								  ((and (list? body) (equal? 'lambda-simple (car body)))
								   (let* ((args (cadr body)))
									 (if (not (member (cadr pvar) args))
										 `(lambda-simple ,args ,@(replace-pvar-bvar pvar (cddr body) 0))
										 body)))
								  ((and (list? body) (equal? 'lambda-opt (car body)))
								   (let* ((args (append (cadr body) `(,(caddr body)))))
									 (if (not (member (cadr pvar) args))
										 `(lambda-opt ,(cadr body) ,(caddr body) ,@(replace-pvar-bvar pvar (cdddr body) 0))
										 body)))
								  ((list? body) `(,(helper (car body) pvar) ,@(helper (cdr body) pvar)))
								  (else body)
							)
						)
					))
		
			(let ((nbody (helper body (car pvars))))
			  (raplace-var-pvar nbody (cdr pvars)))
			)
		)
	)
)

(define replace-pvar-bvar
	(lambda (bvar body depth)
		(cond ((null? body) body)
			((and (list? body) (equal? `(var ,(cadr bvar)) body)) `(bvar ,(cadr bvar) ,depth ,(caddr bvar)))
			((and (list? body) (equal? 'lambda-simple (car body)))
			(let* ((args (cadr body)))
				(if (not (member (cadr bvar) args))
					`(lambda-simple ,args ,@(replace-pvar-bvar bvar (cddr body) (+ 1 depth)))
					body)))
			((and (list? body) (equal? 'lambda-opt (car body)))
			(let* ((args (append (cadr body) `(,(caddr body)))))
				(if (not (member (cadr bvar) args))
					`(lambda-opt ,(cadr body) ,(caddr body) ,@(replace-pvar-bvar bvar (cdddr body) (+ 1 depth)))
					body)))
			((list? body) `(,(replace-pvar-bvar bvar (car body) depth) ,@(replace-pvar-bvar bvar (cdr body) depth)))
			(else body)
		)
	)
)
          
(define make-pvars
	(lambda (proc items)
		(if (null? items)
			(list)
			(cons (proc (car items))
				(make-pvars proc (cdr items))
			)
		)
	)
)          


(define annotate-tc
  	(lambda (expr)
    	(if (null? expr) 
    		expr
      		(annotate-tc-aux expr #f)
      	)
    )
)
 
(define annotate-tc-aux
  	(lambda (expr tp?)
	    (cond ((null? expr) expr)
	    	  ((and (list? expr) (or (eq? (car expr) 'pvar) (eq? (car expr) 'bvar) (eq? (car expr) 'fvar) (eq? (car expr) 'const))) expr) 
	          ((and (list? expr) (eq? (car expr) 'or)) 
	          		(let* ((reverse-expr (reverse (cadr expr)))
	                       (last-expr (car reverse-expr))
	                       (rest-expr (reverse (cdr reverse-expr)))
	       				   (body (append (map annotate-tc rest-expr) (list (annotate-tc-aux last-expr tp?)))))
	            		`(or ,body)))
	          ((and (list? expr) (eq? (car expr) 'seq))
	          		(let* ((reverse-expr (reverse (cadr expr)))
	                       (last-expr (car reverse-expr))
	                       (rest-expr (reverse (cdr reverse-expr)))
	                       (body (append (map annotate-tc rest-expr) (list (annotate-tc-aux last-expr tp?)))))
	            		`(seq  ,body)))
	          ((and (list? expr) (eq? (car expr) 'if3))
	          		(let* ((test (car (cdr expr)))
	             		   (dit (cadr (cdr expr)))
	              		   (dif (caddr (cdr expr))))
	      				`(if3 ,(annotate-tc-aux test #f) ,(annotate-tc-aux dit tp?) ,(annotate-tc-aux dif tp?))))
	          ((and (list? expr) (or (eq? (car expr) 'define) (eq? (car expr) 'set) (eq? (car expr) 'box-set)))
	          		`(,(car expr) ,(cadr expr) ,@(annotate-tc-aux (cddr expr) #f)))
	          ((and (list? expr) (eq? (car expr) 'lambda-simple)) 
	          		`(lambda-simple ,(cadr expr) ,@(annotate-tc-aux (cddr expr) #t)))
	          ((and (list? expr) (eq? (car expr) 'lambda-opt)) 
	          		`(lambda-opt ,(cadr expr) ,(caddr expr) ,@(annotate-tc-aux (cdddr expr) #t)))
	          ((and (list? expr) (eq? (car expr) 'applic)) 
	            	(if tp? 
	            		`(tc-applic ,@(map (lambda (x) (annotate-tc-aux x #f )) (cdr expr)))
	              		`(applic ,@(map (lambda (x) (annotate-tc-aux x #f )) (cdr expr)))))
	          ((list? expr) (map (lambda (x) (annotate-tc-aux x tp?)) expr))
	          (else expr)
	    )
	)
)
